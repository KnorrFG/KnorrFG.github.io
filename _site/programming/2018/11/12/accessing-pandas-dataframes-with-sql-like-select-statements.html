<!DOCTYPE html>
<!--
    So Simple Jekyll Theme 3.1.1
    Copyright 2013-2018 Michael Rose - mademistakes.com | @mmistakes
    Free for personal and commercial use under the MIT license
    https://github.com/mmistakes/so-simple-theme/blob/master/LICENSE
-->
<html lang="en-US" class="no-js">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  

  
    <title>Accessing pandas DataFrame using SQL-like select statements</title>
    <meta name="description" content="Recently I was writing the following code: processing_frame = \ sl_results[sl_results.c == coi][[&quot;subscript&quot;, &quot;kappa&quot;]].rename( columns={&quot;kappa&quot;: &quot;value&quot;}) A...">
    <link rel="canonical" href="http://localhost:4000/programming/2018/11/12/accessing-pandas-dataframes-with-sql-like-select-statements.html">
  

  <script>
    /* Cut the mustard */
    if ( 'querySelector' in document && 'addEventListener' in window ) {
      document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + 'js';
    }
  </script>

  <link rel="stylesheet" href="/assets/css/main.css">
  <link rel="alternate" type="application/atom+xml" title="Felix&#39; Blog" href="/feed.xml">
<!-- start custom head snippets -->

<!-- insert favicons. use http://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

</head>


  <body class="layout--post  accessing-pandas-dataframe-using-sql-like-select-statements">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#primary-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    
  <div class="navigation-wrapper">
    <a href="#menu-toggle" id="menu-toggle">Menu</a>
    <nav id="primary-nav" class="site-nav animated drop">
      <ul><li><a href="/">Home</a></li><li><a href="/about/">About</a></li><li><a href="/categories/">Categories</a></li></ul>
    </nav>
  </div><!-- /.navigation-wrapper -->


    <header class="masthead">
  <div class="wrap">
    
      <a href="/" class="site-logo" rel="home" title="Felix' Blog">
        <img src="/logo.png" class="site-logo-img animated fadeInDown" alt="Felix' Blog">
      </a>
    
    
      <h1 class="site-title animated fadeIn"><a href="/">Felix' Blog</a></h1>
      <p class="site-description animated fadeIn" itemprop="description">A blog about programming, science, and everything else that I might come up with</p>
    
  </div>
</header><!-- /.masthead -->


    <main id="main" class="main-content" aria-label="Content">
  <article class="h-entry">
    

    <div class="page-wrapper">
      <header class="page-header">
        
        
          <h1 id="page-title" class="page-title p-name">Accessing pandas DataFrame using SQL-like select statements
</h1>
        
      </header>

      <div class="page-sidebar">
        <div class="page-author h-card p-author"><div class="author-info"><div class="author-name">
        <span class="p-name">Felix G. Knorr</span>
      </div>
    <time class="page-date dt-published" datetime="2018-11-12T00:00:00+01:00"><a class="u-url" href="">November 12, 2018</a>
</time>

  </div>
</div>

        
  <h3 class="page-taxonomies-title">Categories</h3>
  <ul class="page-taxonomies"><li class="page-taxonomy"><a class="p-category" href="/categories/#programming" title="Pages filed under programming">programming</a></li>
  </ul>


        
  <h3 class="page-taxonomies-title">Tags</h3>
  <ul class="page-taxonomies"><li class="page-taxonomy">python</li><li class="page-taxonomy">pandas</li><li class="page-taxonomy">ast</li>
  </ul>


      </div>

      <div class="page-content">
        <div class="e-content">
          <p>Recently I was writing the following code:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">processing_frame</span> <span class="o">=</span> \
	 <span class="n">sl_results</span><span class="p">[</span><span class="n">sl_results</span><span class="o">.</span><span class="n">c</span> <span class="o">==</span> <span class="n">coi</span><span class="p">][[</span><span class="s">"subscript"</span><span class="p">,</span> <span class="s">"kappa"</span><span class="p">]]</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
		<span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s">"kappa"</span><span class="p">:</span> <span class="s">"value"</span><span class="p">})</span>
</code></pre></div></div>
<p>Another piece of code that might look familiar to the habituated pandas user
is:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_frame</span><span class="p">[(</span><span class="n">my_frame</span><span class="o">.</span><span class="n">col1</span> <span class="o">==</span> <span class="n">a</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">my_frame</span><span class="o">.</span><span class="n">col2</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">my_frame</span><span class="o">.</span><span class="n">col3</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">)]</span>
</code></pre></div></div>
<p>Typing this kind of stuff is annoying, and it triggers me every time I write
something like this. Ideally, this would look more like:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_frame</span><span class="p">[</span><span class="n">col1</span> <span class="o">==</span> <span class="n">a</span> <span class="ow">and</span> <span class="n">col2</span> <span class="o">==</span> <span class="n">b</span> <span class="ow">and</span> <span class="n">col3</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">]</span>
</code></pre></div></div>
<p>which is not supported by the python syntax. What can be done, however, is the
following:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Select</span><span class="p">(</span><span class="s">"subscript, kappa as value"</span><span class="p">)</span><span class="o">.</span><span class="n">Where</span><span class="p">(</span><span class="n">f</span><span class="s">"c == {coi}"</span><span class="p">)(</span><span class="n">sl_results</span><span class="p">)</span>
</code></pre></div></div>

<p>In this post, I’ll walk you through the code that makes the upper statement
possible. For the sake of clearness I will present some code pieces out of
context. If you want to see them in context, you can 
<a href="/assets/code/panql.py">download the code</a>.</p>

<p>Since the Select-part is easier, let’s focus on it first. The grammar looks
like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Expr := &lt;VariableDescription&gt;[, &lt;VariableDescription&gt;, ...]
VariableDescription := &lt;name&gt; [as &lt;alias&gt;]
</code></pre></div></div>

<p>name is a column name, and alias can be chosen freely. So lets see how we
can parse such an expression.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Select</span><span class="p">:</span>
    <span class="n">Var</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">"Var"</span><span class="p">,</span> <span class="p">[</span><span class="s">"name"</span><span class="p">,</span> <span class="s">"alias"</span><span class="p">],</span> <span class="n">defaults</span><span class="o">=</span><span class="p">(</span><span class="bp">None</span><span class="p">,))</span>

    <span class="o">@</span><span class="nb">staticmethod</span>
    <span class="k">def</span> <span class="nf">_to_var</span><span class="p">(</span><span class="n">expression</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Select</span><span class="o">.</span><span class="n">Var</span><span class="p">(</span><span class="o">*</span><span class="n">expression</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">" as "</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instruction</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="nb">vars</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Select</span><span class="o">.</span><span class="n">_to_var</span><span class="p">,</span> <span class="n">instruction</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">","</span><span class="p">)))</span>
</code></pre></div></div>
<p>First, in the <code class="highlighter-rouge">__init__()</code> method, the string is split at the commas, and 
the remaining parts should be
either a column name or a substitution like “kappa as value”. These strings
are mapped through the <code class="highlighter-rouge">_to_var()</code> method. <code class="highlighter-rouge">Var</code> is a <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple">namedtuple</a> that just
stores the name and a possible substitution, which has a default value of
<code class="highlighter-rouge">None</code>, so it can be created by <code class="highlighter-rouge">Var(name, substitution)</code> or just <code class="highlighter-rouge">Var(name)</code>.
Splitting <code class="highlighter-rouge">"kappa as value"</code> at <code class="highlighter-rouge">" as "</code> results in <code class="highlighter-rouge">["kappa", "value"]</code> and
splitting <code class="highlighter-rouge">"kappa"</code> at <code class="highlighter-rouge">" as "</code> results in <code class="highlighter-rouge">["kappa"]</code>. The resulting list can, in
any case, be used as arguments for <code class="highlighter-rouge">Var</code> using the asterisk. So for the string:
<code class="highlighter-rouge">"subscript, kappa as value"</code> <code class="highlighter-rouge">self.vars</code> will be 
<code class="highlighter-rouge">[Var("subscript"), Var("kappa", "value")]</code>. In order to be able to use
<code class="highlighter-rouge">Select(expression)(dataframe)</code> the object needs a <code class="highlighter-rouge">__call__</code> method. Completed
it looks like this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Select</span><span class="p">:</span>
    <span class="n">Var</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">"Var"</span><span class="p">,</span> <span class="p">[</span><span class="s">"name"</span><span class="p">,</span> <span class="s">"alias"</span><span class="p">],</span> <span class="n">defaults</span><span class="o">=</span><span class="p">(</span><span class="bp">None</span><span class="p">,))</span>

    <span class="o">@</span><span class="nb">staticmethod</span>
    <span class="k">def</span> <span class="nf">_to_var</span><span class="p">(</span><span class="n">expression</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Select</span><span class="o">.</span><span class="n">Var</span><span class="p">(</span><span class="o">*</span><span class="n">expression</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">" as "</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instruction</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="nb">vars</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Select</span><span class="o">.</span><span class="n">_to_var</span><span class="p">,</span> <span class="n">instruction</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">","</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span><span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="n">selected_frame</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="n">var</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="nb">vars</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">selected_frame</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span>
            <span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">var</span><span class="o">.</span><span class="n">alias</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="nb">vars</span> <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">alias</span>
        <span class="p">})</span>
</code></pre></div></div>

<p>in the <code class="highlighter-rouge">__call__</code> method we use the <code class="highlighter-rouge">Var.name</code> attribute of all stored vars to
select the columns from the DataFrame that is passed as parameter, and then
rename those columns, for which we have an alias.</p>

<p>The <code class="highlighter-rouge">Where</code> statement will work in a similar fashion, and we add a <code class="highlighter-rouge">Where</code>
method to be able to do something like
<code class="highlighter-rouge">Select(expr).Where(filter_expr)(dataframe)</code></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Select</span><span class="p">:</span>
	<span class="o">...</span>
    <span class="k">def</span> <span class="nf">Where</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span><span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
        <span class="n">where_filter</span> <span class="o">=</span> <span class="n">Where</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">inner_func</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span><span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">(</span><span class="n">where_filter</span><span class="p">(</span><span class="n">df</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">inner_func</span>
</code></pre></div></div>

<p>It simply creates a <code class="highlighter-rouge">Where</code> filter object and returns a function that applies
the filter and then passes the results to its own <code class="highlighter-rouge">__call__</code> method.</p>

<p>So lets look at the <code class="highlighter-rouge">Where</code> class, which is way more exciting.
The <code class="highlighter-rouge">Where</code> object must take a string like <code class="highlighter-rouge">"col1 &gt; 5 and col2 == 'value'"</code> and
filter a DataFrame accordingly. We could try fiddling around with string
splits, but handling all possible operators for all the possible data types
will be hard. Python can already handle this kind of strings, there are
functions like <a href="https://docs.python.org/3/library/functions.html#eval">eval</a> and <a href="https://docs.python.org/3/library/functions.html#exec">exec</a>. But we need to change the interpretation of
the expression slightly. We want to change the <code class="highlighter-rouge">and</code> to a <code class="highlighter-rouge">&amp;</code> and the <code class="highlighter-rouge">or</code> to a 
<code class="highlighter-rouge">|</code>, also we need to change <code class="highlighter-rouge">col1</code> to <code class="highlighter-rouge">my_frame.col1</code>. This can be done using
abstract syntax trees (AST).</p>

<p>But what is an AST? The easiest method to explain is an example. The following
AST belongs to the expression: <code class="highlighter-rouge">"col1 &gt; 5 and col2 == 'value'"</code>:</p>

<div style="text-align: center">
    <img src="/assets/img/ast.png" />
</div>

<p>(BTW: this image was created using the 
<a href="https://vpyast.appspot.com/">Python AST Visualizer</a>)</p>

<p>This looks scary on first sight, but it’s really not that bad. Forget about the
<code class="highlighter-rouge">Module</code> and the <code class="highlighter-rouge">Expr</code> nodes, those don’t matter here. It starts to get interesting
at the <code class="highlighter-rouge">BoolOp</code> node. This node represents the complete (boolean) expression
above. At the upmost level it consists of an <code class="highlighter-rouge">and</code> statement, which has two
values, both of which are comparisons (the <code class="highlighter-rouge">Compare</code> nodes). 
The left comparison has the operation
“greater than” encoded as <code class="highlighter-rouge">Gt</code>, the left value is “col1” which is a node of type
<code class="highlighter-rouge">Name</code> with the id “col1” and the context (ctx) <code class="highlighter-rouge">Load</code> (possible contexts are
<code class="highlighter-rouge">Load</code>, when a variable is accessed, <code class="highlighter-rouge">Store</code>, when a value is assigned, and
<code class="highlighter-rouge">Del</code>, when it’s deleted). “Col1” is compared to 5, which is the first
comparator. If we had used something like “1 &lt; col1 &lt; 10” the left value would
be one, and there would be two comparators, “col1” and 10. The other compare
node works the same. We will now manipulate the tree, and replace the <code class="highlighter-rouge">BoolOp</code>
with <code class="highlighter-rouge">BinOp</code>s. A <code class="highlighter-rouge">BoolOp</code> can have multiple values that are compared, a <code class="highlighter-rouge">BinOp</code>
can only compare two values. Therefore it is necessary to replace the single
<code class="highlighter-rouge">BoolOp</code> with nested <code class="highlighter-rouge">BinOp</code>s like this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">A</span> <span class="ow">and</span> <span class="n">B</span> <span class="ow">and</span> <span class="n">C</span> <span class="ow">and</span> <span class="n">D</span>
<span class="o">-&gt;</span>
<span class="n">A</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">B</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">C</span> <span class="o">&amp;</span> <span class="n">D</span><span class="p">))</span>
</code></pre></div></div>

<p>The other thing we need to change is to transform “col1” to “dataframe.col1”.
For this, we need to exchange the <code class="highlighter-rouge">Name</code> nodes with an <code class="highlighter-rouge">Attribute</code> node, which
is used to get an attribute from an object. To do this we need to know the name
of the object that has the attribute in the scope in which the tree is
evaluated. That is easy though. It is the name of the parameter of
<code class="highlighter-rouge">Where.__call__</code>. So let’s look at the necessary code. First we need to create
an AST based on an expression</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Where</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">filtered_tree</span> <span class="o">=</span> <span class="n">Where</span><span class="o">.</span><span class="n">TreeRewriter</span><span class="p">(</span><span class="s">"df"</span><span class="p">)</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
        <span class="n">expression</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">Expression</span><span class="p">(</span><span class="n">body</span><span class="o">=</span><span class="n">filtered_tree</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">ast</span><span class="o">.</span><span class="n">fix_missing_locations</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compiled_expr</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s">"&lt;ast&gt;"</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">"eval"</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">ast.parse</code> will create the tree from a string. Then the tree will rewritten. The 
<code class="highlighter-rouge">"df"</code> is the name, that the DataFrame will have in the evaluation context. Then
the result is wrapped into an <code class="highlighter-rouge">Expression</code> which is necessary to be able to use
it in combination with <a href="https://docs.python.org/3/library/functions.html#eval">eval</a> instead of <a href="https://docs.python.org/3/library/functions.html#exec">exec</a>. Subsequently we call
<code class="highlighter-rouge">ast.fix_missing_locations()</code>. This is because we will have inserted new nodes
that didn’t exist in the original tree. Every node needs to have a line and a
column referenced to be able to know from which place in the source code it
originated. Our newly created nodes won’t have valid values for these attributes,
and <code class="highlighter-rouge">ast.fix_missing_locations()</code> will fill them in for us. Then we call
<code class="highlighter-rouge">compile</code> on the tree. Additionally we pass the
information, that we want to evaluate the expression instead of executing it 
(which basically means that we want a value back),
and a filename from which the tree was generated. Since we don’t have a file, we
simply pass “&lt;ast&gt;” it could be anything though. We then store away the
compiled expression for later use.</p>

<p>So let’s see how we can actually rewrite this tree. To do this we need a
<a href="https://en.wikipedia.org/wiki/Visitor_pattern">visitor</a> class. This class must have one method for every node type we want to
manipulate, in our case <code class="highlighter-rouge">Name</code> and <code class="highlighter-rouge">BoolOp</code>. The methods must be named
“visit_<Type>" and the class must be derived from `ast.NodeTransformer`. 
These methods must then
return the node that should replace the node that was provided as argument.</Type></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TreeRewriter</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">NodeTransformer</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mat_name</span><span class="p">):</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mat_name</span> <span class="o">=</span> <span class="n">mat_name</span>

        <span class="c1"># some stuff is missing here ...
</span>
        <span class="k">def</span> <span class="nf">visit_Name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">ast</span><span class="o">.</span><span class="n">copy_location</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">Attribute</span><span class="p">(</span>
                <span class="n">value</span><span class="o">=</span><span class="n">ast</span><span class="o">.</span><span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mat_name</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">ast</span><span class="o">.</span><span class="n">Load</span><span class="p">()),</span>
                <span class="n">attr</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="nb">id</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">ast</span><span class="o">.</span><span class="n">Load</span><span class="p">()),</span> <span class="n">node</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">visit_BoolOp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">generic_visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ast</span><span class="o">.</span><span class="n">copy_location</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nested_bin_op</span><span class="p">(</span>
                <span class="n">Select</span><span class="o">.</span><span class="n">TreeRewriter</span><span class="o">.</span><span class="n">_bool_op_replacement_type</span><span class="p">(</span><span class="n">node</span><span class="p">),</span>
                <span class="n">node</span><span class="o">.</span><span class="n">values</span><span class="p">),</span> <span class="n">node</span><span class="p">)</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">visit_Name()</code> method is straight forward: it returns an <code class="highlighter-rouge">ast.Attribute</code> with a
new value, which is the <code class="highlighter-rouge">DataFrame</code>, that will be passed to <code class="highlighter-rouge">Where.__call__</code>,
and the attribute (<code class="highlighter-rouge">attr</code>) will be the id of the <code class="highlighter-rouge">Name</code> node, e.g. “col1”.
Additionally we use <code class="highlighter-rouge">ast.copy_location</code> to copy the location information from
the old node to the new one.</p>

<p>The next method, <code class="highlighter-rouge">visit_BoolOp()</code> is a little more complex. Since the node has
children, that won’t be visited when we replace it, we have to call
<code class="highlighter-rouge">self.generic_visit()</code> on it first. <code class="highlighter-rouge">self.generic_visit()</code> is inherited from
<code class="highlighter-rouge">ast.NodeTransformer</code>. Then we find the type for the new <code class="highlighter-rouge">BinOp</code> via
<code class="highlighter-rouge">Select.TreeRewriter._bool_op_replacement_type()</code>, which is defined as follows:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="nb">staticmethod</span>
<span class="k">def</span> <span class="nf">_bool_op_replacement_type</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ast</span><span class="o">.</span><span class="n">BitAnd</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">And</span><span class="p">)</span>\
        <span class="k">else</span> <span class="n">ast</span><span class="o">.</span><span class="n">BitOr</span>
</code></pre></div></div>

<p>and then create the nested <code class="highlighter-rouge">BinOp</code>s with <code class="highlighter-rouge">self._nested_bin_op()</code> from the
replacement type and the values of the provided <code class="highlighter-rouge">BoolOp</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">_nested_bin_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bop</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
    <span class="n">bot_most</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">BinOp</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                            <span class="n">right</span><span class="o">=</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span>
                            <span class="n">op</span><span class="o">=</span><span class="n">bop</span><span class="p">())</span>
    <span class="n">current_top</span> <span class="o">=</span> <span class="n">bot_most</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">values</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]):</span>
        <span class="n">current_top</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">BinOp</span><span class="p">(</span><span class="n">right</span><span class="o">=</span><span class="n">node</span><span class="p">,</span>
                                <span class="n">left</span><span class="o">=</span><span class="n">current_top</span><span class="p">,</span>
                                <span class="n">op</span><span class="o">=</span><span class="n">bop</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">current_top</span>
</code></pre></div></div>

<p>we start constructing the subtree from the bottom. So for the example 
<code class="highlighter-rouge">a and b and c and d</code> we first create <code class="highlighter-rouge">c &amp; d</code> from there <code class="highlighter-rouge">b &amp; (c &amp; d)</code> and then 
<code class="highlighter-rouge">a &amp; (b &amp; (c &amp; d))</code>.</p>

<p>Now, all that is missing is the application of the compiled tree which happens in
the <code class="highlighter-rouge">Where.__call__()</code> method:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span><span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="n">filter_obj</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compiled_expr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span><span class="p">[</span><span class="n">filter_obj</span><span class="p">]</span>
</code></pre></div></div>

<p>Again, you can download the complete code <a href="/assets/code/panql.py">here</a>. Also if you
want to find out more about the AST, or use it in your own projects, I recommend
<a href="https://greentreesnakes.readthedocs.io/en/latest/">this tutorial</a>.</p>

<p>Using the code presented here is slightly slower than using pandas directly. So
I would not recommend to use a <code class="highlighter-rouge">Select</code> or a <code class="highlighter-rouge">Where</code> inside a loop that is
repeated thousands or millions of times.</p>


        </div>

        
          <div class="page-share">
  <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Flocalhost%3A4000%2Fprogramming%2F2018%2F11%2F12%2Faccessing-pandas-dataframes-with-sql-like-select-statements.html" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" class="btn btn--facebook btn--small"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i> <span>Share</span></a>
  <a href="https://twitter.com/intent/tweet?text=Accessing+pandas+DataFrame+using+SQL-like+select+statements%20http%3A%2F%2Flocalhost%3A4000%2Fprogramming%2F2018%2F11%2F12%2Faccessing-pandas-dataframes-with-sql-like-select-statements.html" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" class="btn btn--twitter btn--small"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i> <span>Tweet</span></a>
  <a href="https://www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Flocalhost%3A4000%2Fprogramming%2F2018%2F11%2F12%2Faccessing-pandas-dataframes-with-sql-like-select-statements.html" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" class="btn btn--linkedin btn--small"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> <span>LinkedIn</span></a>
  <a href="https://reddit.com/submit?title=Accessing+pandas+DataFrame+using+SQL-like+select+statements&url=http%3A%2F%2Flocalhost%3A4000%2Fprogramming%2F2018%2F11%2F12%2Faccessing-pandas-dataframes-with-sql-like-select-statements.html" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" class="btn btn--reddit btn--small"><i class="fab fa-fw fa-reddit" aria-hidden="true"></i> <span>Reddit</span></a>
</div>

        

        
          

        

        <nav class="page-pagination" role="navigation">
  
    <a class="page-previous" href="/programming/2018/11/03/functional-programming.html">
      <h4 class="page-pagination-label">Previous</h4>
      <span class="page-pagination-title">
        <i class="fas fa-arrow-left"></i> Functionalish Programming

      </span>
    </a>
  

  
</nav>

      </div>
    </div>
  </article>
</main>


    <footer id="footer" class="site-footer">
  <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
<div class="social-icons"><a class="social-icon" href="/feed.xml"><i class="fas fa-link fa-2x" title="Feed"></i></a></div><div class="copyright">
    
      <p>&copy; 2018 Felix' Blog. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://github.com/mmistakes/so-simple-theme" rel="nofollow">So Simple</a>.</p>
    
  </div>
</footer>

    <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
  <script src="/assets/js/main.min.js"></script>
  <script src="https://use.fontawesome.com/releases/v5.0.12/js/all.js"></script>


<!-- MathJax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  </body>

</html>
